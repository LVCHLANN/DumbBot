const {
    Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder,
    EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle,
    StringSelectMenuBuilder, AttachmentBuilder, Events
} = require('discord.js');
const { downloadFile, isSupportedFile, getFileType } = require('./utils');
const { convertToImage } = require('./convert');
const path = require('path');
require('dotenv').config();

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
    ],
});

client.once('ready', async () => {
    console.log(`‚úÖ Logged in as ${client.user.tag}`);

    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
    const command = new SlashCommandBuilder()
        .setName('convert')
        .setDescription('Convert a file to an image format')
        .addAttachmentOption(option =>
            option.setName('file')
                .setDescription('File to convert')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('format')
                .setDescription('Output format')
                .setRequired(true)
                .addChoices(
                    { name: 'GIF', value: 'gif' },
                    { name: 'PNG', value: 'png' },
                    { name: 'JPG', value: 'jpg' },
                    { name: 'WEBP', value: 'webp' },
                    { name: 'BMP', value: 'bmp' },
                    { name: 'TIFF', value: 'tiff' },
                    { name: 'AVIF', value: 'avif' }
                )
        );

    try {
        await rest.put(
            Routes.applicationCommands(process.env.CLIENT_ID),
            { body: [command] }
        );
        console.log('‚úÖ Slash command registered or updated.');
    } catch (err) {
        console.error('‚ùå Failed to register slash command:', err);
    }
});

client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isChatInputCommand() || interaction.commandName !== 'convert') return;

    const file = interaction.options.getAttachment('file');
    const format = interaction.options.getString('format');

    if (!isSupportedFile(file.name)) {
        return interaction.reply({ content: '‚ö†Ô∏è Unsupported file type.' });
    }

    await interaction.deferReply();

    try {
        const localPath = await downloadFile(file.url, file.name);
        const outputs = await convertToImage(localPath, format);
        const attachments = outputs.map(p => new AttachmentBuilder(p));

        const reply = await interaction.editReply({
            content: `‚úÖ Converted to **.${format}**:`,
            files: attachments,
            fetchReply: true
        });

        const links = [...reply.attachments.values()].map(a => a.url).join('\n');
        await interaction.followUp({
            content: '```' + links + '```'
        });

    } catch (err) {
        console.error(err);
        await interaction.editReply('‚ùå Conversion failed.');
    }
});

client.on('messageCreate', async message => {
    if (message.author.bot || message.channel.id !== process.env.TARGET_CHANNEL_ID) return;
    if (message.attachments.size === 0) return;

    const links = message.attachments.map(a => a.url).join('\n');
    const embed = new EmbedBuilder()
        .setTitle('üîó Direct File Link(s)')
        .setDescription('```' + links + '```')
        .setFooter({ text: 'Generated by Dumb Bot' })
        .setTimestamp();

    const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
            .setCustomId('convert_button')
            .setLabel('Convert File(s)')
            .setStyle(ButtonStyle.Primary)
    );

    await message.reply({
        embeds: [embed],
        components: [row],
        allowedMentions: { repliedUser: false }
    });
});

client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isButton() || interaction.customId !== 'convert_button') return;

    const replied = interaction.message.reference
        ? await interaction.channel.messages.fetch(interaction.message.reference.messageId)
        : null;

    if (!replied || replied.attachments.size === 0) {
        return interaction.reply({ content: '‚ö†Ô∏è No attachments found.' });
    }

    client.cachedMessage = replied;

    const allFormats = ['gif', 'png', 'jpg', 'webp', 'bmp', 'tiff', 'avif'];
    const excludedFormats = new Set();

    for (const [, attachment] of replied.attachments) {
        const ext = path.extname(attachment.name).toLowerCase().replace('.', '');
        if (allFormats.includes(ext)) excludedFormats.add(ext);
    }

    const formatOptions = allFormats
        .filter(format => !excludedFormats.has(format))
        .map(format => ({ label: format.toUpperCase(), value: format }));

    if (formatOptions.length === 0) {
        return interaction.reply({ content: '‚ö†Ô∏è No valid conversion targets for this file.' });
    }

    const row = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
            .setCustomId('convert_select_format')
            .setPlaceholder('Choose output format')
            .addOptions(formatOptions)
    );

    await interaction.reply({
        content: 'üéØ Choose output format for conversion:',
        components: [row]
    });
});

client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isStringSelectMenu() || interaction.customId !== 'convert_select_format') return;

    const format = interaction.values[0];
    const original = client.cachedMessage;

    if (!original || original.attachments.size === 0) {
        return interaction.update({ content: '‚ö†Ô∏è No valid files found.', components: [] });
    }

    await interaction.update({ content: `‚è≥ Converting file(s) to **.${format}**...`, components: [] });

    try {
        const results = [];
        const cdnLinks = [];

        for (const [, attachment] of original.attachments) {
            if (!isSupportedFile(attachment.name)) continue;

            const localPath = await downloadFile(attachment.url, attachment.name);
            const outputs = await convertToImage(localPath, format);

            outputs.forEach(p => results.push(new AttachmentBuilder(p)));
        }

        if (results.length === 0) {
            return interaction.followUp({ content: '‚ö†Ô∏è No valid files to convert.' });
        }

        const reply = await interaction.followUp({
            content: '‚úÖ Here are your converted files:',
            files: results,
            fetchReply: true
        });

        if (reply && reply.attachments) {
            reply.attachments.forEach(a => cdnLinks.push(a.url));
        }

        await interaction.followUp({
            content: '```' + cdnLinks.join('\n') + '```'
        });

    } catch (err) {
        console.error(err);
        await interaction.followUp({ content: '‚ùå Failed to convert file(s).' });
    }
});

client.login(process.env.DISCORD_TOKEN);
